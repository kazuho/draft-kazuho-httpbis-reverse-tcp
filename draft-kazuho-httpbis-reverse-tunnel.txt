



httpbis                                                           K. Oku
Internet-Draft                                                    Fastly
Intended status: Standards Track                        11 February 2024
Expires: 14 August 2024


                        Reverse Tunnel over HTTP
               draft-kazuho-httpbis-reverse-tunnel-latest

Abstract

   This document specifies the HTTP extension for setting up bi-
   directional byte streams from application servers to their clients by
   using HTTP as a tunnel.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the HTTP Working Group
   mailing list (ietf-http-wg@w3.org), which is archived at
   https://lists.w3.org/Archives/Public/ietf-http-wg/.

   Source for this draft and an issue tracker can be found at
   https://github.com/kazuho/draft-kazuho-httpbis-reverse-tcp.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 14 August 2024.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  The Protocol
     3.1.  HTTP/1.1
     3.2.  HTTP/2 and HTTP/3
   4.  Authentication
   5.  Relaying Connections
     5.1.  Indicating Stand-by for Incoming Connections
     5.2.  Forwarding Client Address
   6.  Application-Layer Protocol Negotiation
     6.1.  Indicating Protocols Available for Use
     6.2.  Indicating the Chosen Protocol
   7.  IANA Considerations
   8.  References
     8.1.  Normative References
     8.2.  Informative References
   Acknowledgments
   Author's Address

1.  Introduction

   In typical application protocols operating on top of TCP, clients
   initiate TCP connections by specifying the server's IP address and
   the port number.  However, not all servers can accept incoming TCP
   connections directly.

   Presently, servers situated behind firewalls that block incoming TCP
   connections often rely on virtual private networks (VPNs).  These
   VPNs enable the passage of packets initiating TCP connections to
   servers through encapsulation, effectively bypassing firewall
   restrictions.  This approach, however, compromises network
   manageability and incurs performance penalties due to the additional
   routing and encapsulation involved.

   This document proposes an alternative method.

   Instead of utilizing VPNs, it describes how servers establish
   connections to clients over HTTP to create bi-directional byte
   streams for applications to exchange information.  Specifically, this
   protocol leverages HTTP upgrades in HTTP/1.1 ([HTTP-SEMANTICS]
   Section 7.8) or the "extended CONNECT" method of HTTP/2
   ([EXTENDED-CONNECT-H2]) and HTTP/3 ([EXTENDED-CONNECT-H3]) to
   establish connections.

   Employing HTTP for connection establishment offers additional
   benefits.  Beyond TLS-based authentication schemes, servers can
   authenticate themselves using varios HTTP-provided authentication
   schemes, such as HTTP authentication and cookies.  Furthermore,
   clients are identified by URI rather than by IP address and port
   number, enhancing flexibility and integration with web technologies.

   As servers specify their clients using URIs, only clients known to a
   server can communicate directly with it.  However, clients can act as
   relays, forwarding TCP connections or application-level messages
   (e.g., HTTP requests) that they accept or receive from the Internet
   to the servers connected through the reverse tunnel.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  The Protocol

   To setup a reverse tunnel, a server connects to the client as
   specified by the URI and issues an HTTP request.

   To signal the intent to establish a reverse tunnel, an upgrade token
   named "reverse" is used.

   The method and the conveyor of the upgrade token are different
   between the HTTP versions.

3.1.  HTTP/1.1

   In HTTP/1.1, the HTTP upgrade mechanism is used ([HTTP-SEMANTICS]
   Section 7.8).

   The method of the issued request SHALL be "GET".

   The upgrade token is conveyed by the "Upgrade" header field, and once
   the reverse tunnel is established successfuly, the client responds
   with a 101 (Swithing Protocols) response.

   Figure 1 shows an exchange of HTTP/1.1 request and response
   establishing a reverse tunnel.

   GET /reverse-endpoint HTTP/1.1
   Connection: upgrade
   Upgrade: reverse

   HTTP/1.1 101 Switching Protocols
   Connection: upgrade
   Upgrade: reverse

            Figure 1: Establishing Reverse Tunnel over HTTP/1.1

3.2.  HTTP/2 and HTTP/3

   In HTTP/2 and HTTP/3, extended CONNECT is used ([EXTENDED-CONNECT-H2]
   or [EXTENDED-CONNECT-H3]).

   In both HTTP versions, the method being used is "CONNECT" and the
   upgrade token is conveyed by the ":protocol" pseudo header.  Once the
   reverse tunnel is established successfully, the client responds with
   a 200 (OK) response.

4.  Authentication

   When HTTPS is used for establishing the tunnel, the client (i.e., the
   node acting as the TLS server) SHOULD use one of the TLS-based
   authentication schemes to identify itself.

   The server SHOULD authenticate itself either by using one of the
   HTTP-based authentication schemes (e.g., HTTP Basic Authentication
   [BASIC-AUTH]) or by using one of the TLS-based authentication schemes
   when HTTPS is used.

5.  Relaying Connections

   When the client is acting as a transport-layer protocol relay (i.e.,
   forwarding connections), it is the responsibility of the reverse
   tunnel protocol to indicate when the relayed connection has been
   established and also the identity of the client.

5.1.  Indicating Stand-by for Incoming Connections

   When a client acting as a transport-layer protocol relay receives a
   request to establish a reverse tunnel, the client SHOULD intially
   send an informational HTTP response of status code 100 (Continue), to
   indicate that the client is willing to serve as a tunnel but that no
   connections are immediately available to be relayed.

   Once a connection to be relayed becomes available, the client sends a
   successful response (i.e., 101 Switching Protocols or 200 OK
   depending on the version of the HTTP protocol being used) to indicate
   that the client has started to act as a relay.

   The client MAY send 100 responses more than once.

   If the client instantly matched a connection to be relayed to the
   tunnel establishment request, the client MAY omit the 100 response
   and send a successful response immediately.

5.2.  Forwarding Client Address

   When sending a successful HTTP response, clients MAY include the
   "Forwarded" header field [FORWARDED] in the HTTP response to indicate
   the client identity of the relayed connection.  For clients acting as
   a transport-layer relay, use of the "Forwarded" response header field
   is the only way to relay the identity.

   Figure 2 shows an exchange of HTTP/1.1 messages to establish a
   reverse TCP relay, with the final response indicating the client-side
   address of the connection being relayed.

   GET /reverse-tcp-relay HTTP/1.1
   Connection: upgrade
   Upgrade: reverse

   HTTP/1.1 100 Continue

   HTTP/1.1 101 Switching Protocols
   Connection: upgrade
   Upgrade: reverse
   Forwarded: for=192.0.2.43

                     Figure 2: Establishing a TCP relay

   When the client is an application-protocol relay, it MAY use the
   mechanism provided by the application protocols to relay the identity
   of the client being relayed.  For example, a client acting as a HTTP
   proxy can forward HTTP requests to servers at the HTTP request level,
   indicating the IP address of the HTTP clients by adding the Forwarded
   header field to each of the HTTP request that it forwards.

6.  Application-Layer Protocol Negotiation

   As the use of TLS [TLS] becomes prevalent, an increasing number of
   application protocols depend on the Application-Layer Protocol
   Negotiation Extension [ALPN] to determine the application protocol to
   utilize.

   While TLS can be used on top of the established tunnel and the
   application protocol can be negotiated during the TLS handshake,
   doing so is not necessary to achieve the goal of encryption when the
   tunnel is established via HTTPS.  When operating over HTTPS, some
   deployments could opt to exchange messages without having another
   layer of encryption above the tunnel.

   This document specifies an HTTP header-based mechanism for
   negotiating the application protocol.  ALPN identifiers are used for
   naming the application protocols, so that existing application
   procotols can be selected.

6.1.  Indicating Protocols Available for Use

   To indicate the application protocols that the server is willing to
   utilize, a server MAY include an "ALPN" header field [ALPN-HEADER] in
   the HTTP request that it issues.  The "ALPN" header field carries a
   list of application-protocol identifies that the server is willing to
   use.

   Figure 3 shows an HTTP/1.1 request attempting to establish a reverse
   channel that uses either HTTP/2 [HTTP2] or HTTP/1.1 [HTTP1] as the
   application protocol.

   GET /endpoint HTTP/1.1
   Connection: upgrade
   Upgrade: reverse
   ALPN: h2, http%2F1.1

                Figure 3: Request with an ALPN Header Field

6.2.  Indicating the Chosen Protocol

   When a client receives an HTTP request with an "ALPN" header field,
   and if the client decides to select one of the application protocols
   being offered, the client includes a "Selected-ALPN" header field in
   the HTTP response.

   If the HTTP request does not include an "ALPN" header field, the
   client MUST NOT send a "Selected-ALPN" header field.

   Syntax of the "Selected-ALPN" header field is as follows.  The syntax
   reuses the encoding of the "ALPN" header field, but always includes
   exactly one application-protocol identifier that is being chosen.

   Selected-ALPN = ALPN

   Figure 4 shows an HTTP/1.1 response indicating that the tunnel has
   been established with the chosen protocol being HTTP/2.

   HTTP/1.1 101 Switching Protocols
   Connection: upgrade
   Upgrade: reverse
   Selected-ALPN: h2

            Figure 4: Response with a Selected-ALPN Header Field

   When a server receives a successful HTTP response that does not carry
   the "Selected-ALPN" header field, it could either be an indication
   that the server chose another application protocol or that the server
   could not determine which application protocol has been chosen.
   Therefore, the client SHOULD NOT assume that an application protocol
   other than the ones being offered has been selected.

7.  IANA Considerations

   TBD.

8.  References

8.1.  Normative References

   [ALPN]     Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <https://www.rfc-editor.org/rfc/rfc7301>.

   [ALPN-HEADER]
              Hutton, A., Uberti, J., and M. Thomson, "The ALPN HTTP
              Header Field", RFC 7639, DOI 10.17487/RFC7639, August
              2015, <https://www.rfc-editor.org/rfc/rfc7639>.

   [EXTENDED-CONNECT-H2]
              McManus, P., "Bootstrapping WebSockets with HTTP/2",
              RFC 8441, DOI 10.17487/RFC8441, September 2018,
              <https://www.rfc-editor.org/rfc/rfc8441>.

   [EXTENDED-CONNECT-H3]
              Hamilton, R., "Bootstrapping WebSockets with HTTP/3",
              RFC 9220, DOI 10.17487/RFC9220, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9220>.

   [FORWARDED]
              Petersson, A. and M. Nilsson, "Forwarded HTTP Extension",
              RFC 7239, DOI 10.17487/RFC7239, June 2014,
              <https://www.rfc-editor.org/rfc/rfc7239>.

   [HTTP-SEMANTICS]
              Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9110>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

8.2.  Informative References

   [BASIC-AUTH]
              Reschke, J., "The 'Basic' HTTP Authentication Scheme",
              RFC 7617, DOI 10.17487/RFC7617, September 2015,
              <https://www.rfc-editor.org/rfc/rfc7617>.

   [HTTP1]    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP/1.1", STD 99, RFC 9112, DOI 10.17487/RFC9112,
              June 2022, <https://www.rfc-editor.org/rfc/rfc9112>.

   [HTTP2]    Thomson, M., Ed. and C. Benfield, Ed., "HTTP/2", RFC 9113,
              DOI 10.17487/RFC9113, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9113>.

   [TLS]      Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/rfc/rfc8446>.

Acknowledgments

   TODO acknowledge.

Author's Address

   Kazuho Oku
   Fastly
   Email: kazuhooku@gmail.com
